# Save processed data
save(df, file = "C:/Users/LENOVO/Desktop/R/Final_Work/df.rdata")
# No need to remove duplicate rows because in this dataset,
# identical rows are a natural part of the data structure.
# Each participant completed multiple trials, and some trials
# may have the exact same values for contrast, WMresp_acc, and PASkey.keys.
# These repetitions do not indicate redundant data but rather reflect
# the actual design of the experiment.
# Load the data set
load("C:/Users/LENOVO/Desktop/R/Final_Work/df.rdata")
# Compute descriptive statistics (Mean & SE)
summary_stats <- df |>
summarise(
PAS_Mean = mean(PASkey.keys), PAS_SE = sd(PASkey.keys) / sqrt(n()),
WM_Mean = mean(WMresp_acc), WM_SE = sd(WMresp_acc) / sqrt(n()),
Contrast_Mean = mean(contrast), Contrast_SE = sd(contrast) / sqrt(n())
)
# Create a summary table with rounded values
summary_table <- data.frame(
Variable = c("PAS Score", "WM Accuracy", "Contrast"),
Mean = round(c(summary_stats$PAS_Mean, summary_stats$WM_Mean, summary_stats$Contrast_Mean), 3),
SE = round(c(summary_stats$PAS_SE, summary_stats$WM_SE, summary_stats$Contrast_SE), 3)
)
# Display the table using kable
kable(summary_table, caption = "Summary Statistics: Mean and Standard Error")
# Compute mean and standard error of WM Accuracy for each PAS score
pas_summary <- df |>
group_by(PASkey.keys) |>
summarise(
WM_Mean = round(mean(WMresp_acc), 3),
WM_SE = round(sd(WMresp_acc) / sqrt(n()), 3)
)
# Display summary table using kable
kable(pas_summary, caption = "WM Accuracy: Mean and Standard Error by PAS Score")
#Density plot for PAS
Mean <- mean(df$PASkey.keys)
Median <- median(df$PASkey.keys)
ggplot(df, aes(x = PASkey.keys)) +
geom_density(aes(y = ..scaled..),
fill = "skyblue", alpha = 0.5,
color = "blue", size = 1.2) +
geom_jitter(data = df[sample(nrow(df), 1000), ],
aes(y = -0.05), color = "black",
alpha = 0.3, height = 0.02) +
geom_vline(xintercept = Mean, color = "blue", linetype = "dotted", size = 1) +
geom_vline(xintercept = Median, color = "red", linetype = "dashed", size = 1) +
annotate("text", x = Mean, y = 0.9, label = "Mean", color = "blue", angle = 90, vjust = -0.5) +
annotate("text", x = Median, y = 0.9, label = "Median", color = "red",angle = 90, vjust = -0.5) +
scale_x_continuous(breaks = seq(floor(min(df$PASkey.keys)), ceiling(max(df$PASkey.keys)), by = 1)) +
labs(
title = "Distribution of PAS Scores",
subtitle = "Density Plot with Mean, Median, and Sampled Observations",
x = "PAS Score",
y = "Density (Scaled)"
) +
theme_minimal()
# Histogram for WM Accuracy (Success vs. Failure)
ggplot(df, aes(x = factor(WMresp_acc, levels = c(0, 1), labels = c("Failure", "Success")))) +
geom_bar(fill = "lightgreen", alpha = 0.6) +
geom_text(stat = "count", aes(label = ..count..),
vjust = -0.3, size = 5, fontface = "bold") +
ylim(0, max(table(df$WMresp_acc)) * 1.1) +
labs(title = "Histogram of Success Rate", x = "Outcome", y = "Frequency") +
theme_minimal()
# Density plot for Contrast
ggplot(df, aes(x = contrast)) +
geom_density(fill = "lightblue", alpha = 0.5, color = "blue", size = 1.2) +
geom_vline(xintercept = summary_stats$Contrast_Mean, color = "red", linetype = "dashed", size = 1) +
geom_vline(xintercept = median(df$contrast), color = "purple", linetype = "dotted", size = 1) +
annotate("text", x = summary_stats$Contrast_Mean + 0.025,
y = 0.6 * max(density(df$contrast)$y), label = "Mean", color = "red", angle = 90, hjust = -1, size = 5) +
annotate("text", x = median(df$contrast) + 0.05,
y = 0.5 * max(density(df$contrast)$y), label = "Median", color = "purple", angle = 90, hjust = 0, size = 5) +
labs(title = "Density Plot of Contrast", x = "Contrast", y = "Density") +
theme_minimal()
# Bar plot for accuracy in each PAS
ggplot(pas_summary, aes(x = PASkey.keys, y = WM_Mean)) +
geom_point(size = 4, color = "blue") +  # Points for each PAS score
geom_line(group = 1, color = "blue", size = 1) +  # Line connecting points
geom_errorbar(aes(ymin = WM_Mean - WM_SE, ymax = WM_Mean + WM_SE),
width = 0.2, color = "black", size = 1) +  # Error bars
labs(
title = "WM Accuracy by PAS Score",
x = "PAS Score",
y = "Mean WM Accuracy"
) +
theme_minimal()
##Plot of PAS in each level of contrast
# Step 1: Define the number of bins (4 groups)
bin_size <- max(df$contrast) / 4
# Step 2: Create a new factor variable by binning contrast
df <- df |>
mutate(contrast_factor = cut(contrast,
breaks = seq(0, max(contrast), by = bin_size),
include.lowest = TRUE,
labels = c("Low", "Medium-Low", "Medium-High", "High")))
# Step 3: Calculate mean PAS and standard error (SE) for each contrast bin
PAS_by_contrast <- df |>
group_by(contrast_factor) |>
summarise(
mean_PAS = round(mean(PASkey.keys), 3),
se_PAS_by_factor = round(sd(PASkey.keys) / sqrt(n()), 3)
)
# Step 4: Create plot
ggplot(PAS_by_contrast, aes(x = contrast_factor, y = mean_PAS, group = 1)) +
geom_point(size = 4, color = "blue") +  # Consistent with other plots
geom_line(color = "blue", linewidth = 1) +
geom_errorbar(aes(ymin = mean_PAS - se_PAS_by_factor, ymax = mean_PAS + se_PAS_by_factor),
width = 0.2, color = "black", size = 1) +
labs(
title = "Mean PAS Score by Contrast Level (Binned)",
x = "Contrast Level",
y = "Mean PAS Score"
) +
theme_minimal()
save(df, file = "C:/Users/LENOVO/Desktop/R/Final_Work/df.rdata")
load("C:/Users/LENOVO/Desktop/R/Final_Work/df.rdata")
# Function to calculate the mean PAS, success rate, and contrast for each participant
calculate_participant_means <- function(df) {
# Check if the dataframe contains the required columns
required_columns <- c("participant", "PASkey.keys", "WMresp_acc", "contrast")
missing_columns <- setdiff(required_columns, colnames(df))
if (length(missing_columns) > 0) {
return(paste("Error: The following required columns are missing from the dataframe:",
paste(missing_columns, collapse = ", ")))
}
# Compute the means for each participant
result <- df |>
group_by(participant) |>
summarise(
mean_PAS = mean(PASkey.keys, na.rm = TRUE),       # Calculate mean PAS
mean_success = mean(WMresp_acc, na.rm = TRUE),    # Calculate mean success rate
mean_contrast = mean(contrast, na.rm = TRUE)      # Calculate mean contrast
) |>
mutate(across(starts_with("mean_"), round, 3))  # Round all mean values to 3 decimal places
# Return the computed dataframe
return(result)
}
# Apply the function to the dataset and store the result
participant_summary <- calculate_participant_means(df)
# Print the result
print(head(participant_summary, 3))
# Bonus: Function to compute standard errors (SE) for PAS and contrast using data.table
compute_se <- function(dt) {
result <- dt[, lapply(.SD, function(x) round(sd(x) / sqrt(.N), 3)),
by = participant,
.SDcols = c("PASkey.keys", "contrast")]
setnames(result, old = c("PASkey.keys", "contrast"),
new = c("se_PAS", "se_contrast"))
return(result)
}
# Convert df to data.table and apply the function
df_dt <- as.data.table(df)
se_results <- compute_se(df_dt)
# Print the result
print(head(se_results, 3))
save(df, file = "C:/Users/LENOVO/Desktop/R/Final_Work/df.rdata")
# Load the dataset
load("C:/Users/LENOVO/Desktop/R/Final_Work/df.rdata")
#### REGRESSION ----
#for the regression I subtracted from every PAS 1 so 0 represent the reference level
df$PASkey.keys <- df$PASkey.keys - 1
# Logistic Regression: predicting success by Perceptual Awareness Scale (PAS)
accuracy_by_PAS <- glm(WMresp_acc ~ PASkey.keys,
data = df,
family = binomial)
# Print summary of the logistic regression model
summary(accuracy_by_PAS)
# Compute Odds Ratio (OR) and 95% Confidence Intervals
conf_int <- exp(confint.default(accuracy_by_PAS))  # Convert CI to OR scale
odds_ratios <- exp(coef(accuracy_by_PAS))  # Convert log-odds to OR
# Print results
print(conf_int)
print(odds_ratios)
#Correlation
df$WMresp_acc <- as.numeric(df$WMresp_acc)# changing to numeric for Pearson correlation
cor.test(df$PASkey.keys, df$WMresp_acc, method = "pearson") #correlation
#Logistic regression plot
#moving the blue dots to the left
pas_summary$PASkey.num <- pas_summary$PASkey.keys - 1
ggplot(df, aes(x = PASkey.keys, y = WMresp_acc)) +
geom_smooth(method = "glm", method.args = list(family = "binomial"),
color = "red", fill = "pink", alpha = 0.3, se = TRUE) +  # Logistic regression curve
geom_point(data = pas_summary, aes(x = PASkey.num, y = WM_Mean), color = "blue", size = 4) +  # שינוי רק בנקודות
scale_x_continuous(breaks = c(0, 1, 2, 3)) +
scale_y_continuous(labels = percent_format()) +
labs(
title = "Predicted Success Probability by PAS Score",
x = "PAS Score (0-3)",
y = "Probability of Success in WM Task",
caption = "Logistic regression model with confidence intervals"
) +
theme_minimal() +
theme(text = element_text(size = 14))
#ROC
roc_curve <- roc(df$WMresp_acc, fitted(accuracy_by_PAS))
auc_value <- auc(roc_curve)
# Print AUC
print(auc_value)
# Plot ROC curve
ggplot(data.frame(TPR = rev(roc_curve$sensitivities),
FPR = rev(1 - roc_curve$specificities)),
aes(x = FPR, y = TPR)) +
geom_line(color = "blue", size = 1.2) +
geom_abline(linetype = "dashed", color = "red") +
labs(title = "ROC Curve",
x = "False Positive Rate",
y = "True Positive Rate") +
theme_minimal()
# Calculate and print the AIC of the logistic regression model
aic_value_logistic <- AIC(accuracy_by_PAS)
print(aic_value_logistic)
#Multiple Linear Regression: predicting PAS by contrast level
PAS_by_contrast_and_succession <- lm(PASkey.keys ~ contrast * WMresp_acc, data = df)
summary(PAS_by_contrast_and_succession)
df$WMresp_acc <- as.factor(df$WMresp_acc)
ggplot(df, aes(x = contrast, y = PASkey.keys, color = factor(WMresp_acc))) +
geom_smooth(method = "lm", se = TRUE) +
scale_color_manual(values = c("red", "blue"), labels = c("Failure (0)", "Success (1)")) +
labs(
title = "Regression of PAS on Contrast by Success/Failure",
x = "Contrast",
y = "PAS",
color = "Outcome"
) +
theme_minimal() +
theme(
text = element_text(size = 14),
plot.title = element_text(size = 13, hjust = 0.5, margin = margin(b = 5))
)
aic_value_linear <- AIC(PAS_by_contrast_and_succession)
print(aic_value_linear)
rm(list = ls())  # Clear workspace
# Final Work
# Name of submitter: Asaf Hoory
# ID: 211677174
rm(list = ls())  # Clear workspace
# Load required libraries
library(dplyr)
library(readr)
library(tidyverse)
library(ggplot2)
library(data.table)
library(pROC)
library(knitr)
library(scales)
#### EXPLORATORY DATA ----
# This part of the code preprocesses the data and extracts only the relevant variables.
# WMrep_acc describes accuracy in the main task, PASkey.keys describes the PAS report, and contrast represents the contrast level.
# Each participant completed 720 trials divided into two sessions. Hence, df consists of 14,400 lines.
# Creating data frame of all 20 subjects
folder_path <- "C:/Users/LENOVO/Desktop/R/Final_Work/data"
files <- list.files(path = folder_path, pattern = "\\.csv$", full.names = TRUE)
df <- files |>
map_df(~ read_csv(.x, col_types = cols(.default = "c"), show_col_types = FALSE) |>
mutate(file_name = basename(.x)))
# Ensure all required columns exist
required_columns <- c("contrast", "WMresp_acc", "PASkey.keys", "session", "participant")
missing_columns <- setdiff(required_columns, names(df))
if (length(missing_columns) > 0) {
stop("Missing columns in dataset: ", paste(missing_columns, collapse = ", "))
}
# Select relevant columns and remove rows with missing values
df <- df |>
select(all_of(required_columns)) |>
filter(!if_any(everything(), is.na))
# Fix participant naming
df <- df |>
mutate(participant = recode(participant, "P1" = "1")) |>
mutate(participant = as.numeric(participant)) |>  # Convert to numeric
arrange(participant)
# Convert multiple columns to numeric
df <- df |>
mutate(WMresp_acc = as.numeric(WMresp_acc)) |>
mutate(PASkey.keys = as.numeric(PASkey.keys)) |>#PAS temporarily defined as numeric because I wanted to calculate mean and SE in the descriptive part, in the regression it will be change to factor
mutate(contrast = as.numeric(contrast))
# No need to remove duplicate rows because in this dataset,
# identical rows are a natural part of the data structure.
# Each participant completed multiple trials, and some trials
# may have the exact same values for contrast, WMresp_acc, and PASkey.keys.
# These repetitions do not indicate redundant data but rather reflect
# the actual design of the experiment.
# Compute descriptive statistics (Mean & SE)
summary_stats <- df |>
summarise(
PAS_Mean = mean(PASkey.keys), PAS_SE = sd(PASkey.keys) / sqrt(n()),
WM_Mean = mean(WMresp_acc), WM_SE = sd(WMresp_acc) / sqrt(n()),
Contrast_Mean = mean(contrast), Contrast_SE = sd(contrast) / sqrt(n())
)
# Create a summary table with rounded values
summary_table <- data.frame(
Variable = c("PAS Score", "WM Accuracy", "Contrast"),
Mean = round(c(summary_stats$PAS_Mean, summary_stats$WM_Mean, summary_stats$Contrast_Mean), 3),
SE = round(c(summary_stats$PAS_SE, summary_stats$WM_SE, summary_stats$Contrast_SE), 3)
)
# Display the table using kable
kable(summary_table, caption = "Summary Statistics: Mean and Standard Error")
# Compute mean and standard error of WM Accuracy for each PAS score
pas_summary <- df |>
group_by(PASkey.keys) |>
summarise(
WM_Mean = round(mean(WMresp_acc), 3),
WM_SE = round(sd(WMresp_acc) / sqrt(n()), 3)
)
# Display summary table using kable
kable(pas_summary, caption = "WM Accuracy: Mean and Standard Error by PAS Score")
#Density plot for PAS
Mean <- mean(df$PASkey.keys)
Median <- median(df$PASkey.keys)
ggplot(df, aes(x = PASkey.keys)) +
geom_density(aes(y = ..scaled..),
fill = "skyblue", alpha = 0.5,
color = "blue", size = 1.2) +
geom_jitter(data = df[sample(nrow(df), 1000), ],
aes(y = -0.05), color = "black",
alpha = 0.3, height = 0.02) +
geom_vline(xintercept = Mean, color = "blue", linetype = "dotted", size = 1) +
geom_vline(xintercept = Median, color = "red", linetype = "dashed", size = 1) +
annotate("text", x = Mean, y = 0.9, label = "Mean", color = "blue", angle = 90, vjust = -0.5) +
annotate("text", x = Median, y = 0.9, label = "Median", color = "red",angle = 90, vjust = -0.5) +
scale_x_continuous(breaks = seq(floor(min(df$PASkey.keys)), ceiling(max(df$PASkey.keys)), by = 1)) +
labs(
title = "Distribution of PAS Scores",
subtitle = "Density Plot with Mean, Median, and Sampled Observations",
x = "PAS Score",
y = "Density (Scaled)"
) +
theme_minimal()
# Histogram for WM Accuracy (Success vs. Failure)
ggplot(df, aes(x = factor(WMresp_acc, levels = c(0, 1), labels = c("Failure", "Success")))) +
geom_bar(fill = "lightgreen", alpha = 0.6) +
geom_text(stat = "count", aes(label = ..count..),
vjust = -0.3, size = 5, fontface = "bold") +
ylim(0, max(table(df$WMresp_acc)) * 1.1) +
labs(title = "Histogram of Success Rate", x = "Outcome", y = "Frequency") +
theme_minimal()
# Density plot for Contrast
ggplot(df, aes(x = contrast)) +
geom_density(fill = "lightblue", alpha = 0.5, color = "blue", size = 1.2) +
geom_vline(xintercept = summary_stats$Contrast_Mean, color = "red", linetype = "dashed", size = 1) +
geom_vline(xintercept = median(df$contrast), color = "purple", linetype = "dotted", size = 1) +
annotate("text", x = summary_stats$Contrast_Mean + 0.025,
y = 0.6 * max(density(df$contrast)$y), label = "Mean", color = "red", angle = 90, hjust = -1, size = 5) +
annotate("text", x = median(df$contrast) + 0.05,
y = 0.5 * max(density(df$contrast)$y), label = "Median", color = "purple", angle = 90, hjust = 0, size = 5) +
labs(title = "Density Plot of Contrast", x = "Contrast", y = "Density") +
theme_minimal()
# Bar plot for accuracy in each PAS
ggplot(pas_summary, aes(x = PASkey.keys, y = WM_Mean)) +
geom_point(size = 4, color = "blue") +  # Points for each PAS score
geom_line(group = 1, color = "blue", size = 1) +  # Line connecting points
geom_errorbar(aes(ymin = WM_Mean - WM_SE, ymax = WM_Mean + WM_SE),
width = 0.2, color = "black", size = 1) +  # Error bars
labs(
title = "WM Accuracy by PAS Score",
x = "PAS Score",
y = "Mean WM Accuracy"
) +
theme_minimal()
##Plot of PAS in each level of contrast
# Step 1: Define the number of bins (4 groups)
bin_size <- max(df$contrast) / 4
# Step 2: Create a new factor variable by binning contrast
df <- df |>
mutate(contrast_factor = cut(contrast,
breaks = seq(0, max(contrast), by = bin_size),
include.lowest = TRUE,
labels = c("Low", "Medium-Low", "Medium-High", "High")))
# Step 3: Calculate mean PAS and standard error (SE) for each contrast bin
PAS_by_contrast <- df |>
group_by(contrast_factor) |>
summarise(
mean_PAS = round(mean(PASkey.keys), 3),
se_PAS_by_factor = round(sd(PASkey.keys) / sqrt(n()), 3)
)
# Step 4: Create plot
ggplot(PAS_by_contrast, aes(x = contrast_factor, y = mean_PAS, group = 1)) +
geom_point(size = 4, color = "blue") +  # Consistent with other plots
geom_line(color = "blue", linewidth = 1) +
geom_errorbar(aes(ymin = mean_PAS - se_PAS_by_factor, ymax = mean_PAS + se_PAS_by_factor),
width = 0.2, color = "black", size = 1) +
labs(
title = "Mean PAS Score by Contrast Level (Binned)",
x = "Contrast Level",
y = "Mean PAS Score"
) +
theme_minimal()
# Function to calculate the mean PAS, success rate, and contrast for each participant
calculate_participant_means <- function(df) {
# Check if the dataframe contains the required columns
required_columns <- c("participant", "PASkey.keys", "WMresp_acc", "contrast")
missing_columns <- setdiff(required_columns, colnames(df))
if (length(missing_columns) > 0) {
return(paste("Error: The following required columns are missing from the dataframe:",
paste(missing_columns, collapse = ", ")))
}
# Compute the means for each participant
result <- df |>
group_by(participant) |>
summarise(
mean_PAS = mean(PASkey.keys, na.rm = TRUE),       # Calculate mean PAS
mean_success = mean(WMresp_acc, na.rm = TRUE),    # Calculate mean success rate
mean_contrast = mean(contrast, na.rm = TRUE)      # Calculate mean contrast
) |>
mutate(across(starts_with("mean_"), round, 3))  # Round all mean values to 3 decimal places
# Return the computed dataframe
return(result)
}
# Apply the function to the dataset and store the result
participant_summary <- calculate_participant_means(df)
# Print the result
print(head(participant_summary, 3))
#      participant    mean_PAS  mean_success   mean_contrast
#1           1        1.49         0.756           0.061
#2           2        1.58         0.581           0.110
#3           3        1.57         0.525           0.058
# Bonus: Function to compute standard errors (SE) for PAS and contrast using data.table
compute_se <- function(dt) {
result <- dt[, lapply(.SD, function(x) round(sd(x) / sqrt(.N), 3)),
by = participant,
.SDcols = c("PASkey.keys", "contrast")]
setnames(result, old = c("PASkey.keys", "contrast"),
new = c("se_PAS", "se_contrast"))
return(result)
}
# Convert df to data.table and apply the function
df_dt <- as.data.table(df)
se_results <- compute_se(df_dt)
# Print the result
print(head(se_results, 3))
#       participant  se_PAS    se_contrast
#1:           1      0.026       0.003
#2:           2      0.031       0.003
#3:           3      0.026       0.002
#### REGRESSION ----
#for the regression I subtracted from every PAS 1 so 0 represent the reference level
df$PASkey.keys <- df$PASkey.keys - 1
# Logistic Regression: predicting success by Perceptual Awareness Scale (PAS)
accuracy_by_PAS <- glm(WMresp_acc ~ PASkey.keys,
data = df,
family = binomial)
# Print summary of the logistic regression model
summary(accuracy_by_PAS)
# Compute Odds Ratio (OR) and 95% Confidence Intervals
conf_int <- exp(confint.default(accuracy_by_PAS))  # Convert CI to OR scale
odds_ratios <- exp(coef(accuracy_by_PAS))  # Convert log-odds to OR
# Print results
print(conf_int)
print(odds_ratios)
#Correlation
df$WMresp_acc <- as.numeric(df$WMresp_acc)# changing to numeric for Pearson correlation
cor.test(df$PASkey.keys, df$WMresp_acc, method = "pearson") #correlation
#Logistic regression plot
#moving the blue dots to the left
pas_summary$PASkey.num <- pas_summary$PASkey.keys - 1
ggplot(df, aes(x = PASkey.keys, y = WMresp_acc)) +
geom_smooth(method = "glm", method.args = list(family = "binomial"),
color = "red", fill = "pink", alpha = 0.3, se = TRUE) +  # Logistic regression curve
geom_point(data = pas_summary, aes(x = PASkey.num, y = WM_Mean), color = "blue", size = 4) +  # שינוי רק בנקודות
scale_x_continuous(breaks = c(0, 1, 2, 3)) +
scale_y_continuous(labels = percent_format()) +
labs(
title = "Predicted Success Probability by PAS Score",
x = "PAS Score (0-3)",
y = "Probability of Success in WM Task",
caption = "Logistic regression model with confidence intervals"
) +
theme_minimal() +
theme(text = element_text(size = 14))
#ROC
roc_curve <- roc(df$WMresp_acc, fitted(accuracy_by_PAS))
auc_value <- auc(roc_curve)
# Print AUC
print(auc_value)
# Plot ROC curve
ggplot(data.frame(TPR = rev(roc_curve$sensitivities),
FPR = rev(1 - roc_curve$specificities)),
aes(x = FPR, y = TPR)) +
geom_line(color = "blue", size = 1.2) +
geom_abline(linetype = "dashed", color = "red") +
labs(title = "ROC Curve",
x = "False Positive Rate",
y = "True Positive Rate") +
theme_minimal()
# Calculate and print the AIC of the logistic regression model
aic_value_logistic <- AIC(accuracy_by_PAS)
print(aic_value_logistic)
#Multiple Linear Regression: predicting PAS by contrast level
PAS_by_contrast_and_succession <- lm(PASkey.keys ~ contrast * WMresp_acc, data = df)
summary(PAS_by_contrast_and_succession)
df$WMresp_acc <- as.factor(df$WMresp_acc)
ggplot(df, aes(x = contrast, y = PASkey.keys, color = factor(WMresp_acc))) +
geom_smooth(method = "lm", se = TRUE) +
scale_color_manual(values = c("red", "blue"), labels = c("Failure (0)", "Success (1)")) +
labs(
title = "Regression of PAS on Contrast by Success/Failure",
x = "Contrast",
y = "PAS",
color = "Outcome"
) +
theme_minimal() +
theme(
text = element_text(size = 14),
plot.title = element_text(size = 13, hjust = 0.5, margin = margin(b = 5))
)
aic_value_linear <- AIC(PAS_by_contrast_and_succession)
print(aic_value_linear)
#AIC = 41391.94
#AIC = 41391.94
#AIC = 41391.94
#AIC = 41391.94
#AIC = 41391.94
